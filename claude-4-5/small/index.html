<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NanoStream - Live Streaming Platform</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: #18181b;
      color: #f9f9f9;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      overflow-x: hidden;
    }

    .gradient-bg {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .gradient-text {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .input-field {
      background-color: #27272a;
      border: 2px solid #3f3f46;
      color: #f9f9f9;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      width: 100%;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .input-field:focus {
      outline: none;
      border-color: #7c3aed;
      box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(124, 58, 237, 0.3);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background-color: #27272a;
      color: #f9f9f9;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      border: 2px solid #3f3f46;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .btn-secondary:hover {
      border-color: #7c3aed;
      background-color: #3f3f46;
    }

    .btn-danger {
      background-color: #dc2626;
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .btn-danger:hover {
      background-color: #b91c1c;
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(220, 38, 38, 0.3);
    }

    .btn-success {
      background-color: #16a34a;
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .btn-success:hover {
      background-color: #15803d;
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(22, 163, 74, 0.3);
    }

    .card {
      background-color: #27272a;
      border-radius: 1rem;
      padding: 2rem;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
      border: 1px solid #3f3f46;
    }

    .video-container {
      position: relative;
      width: 100%;
      background-color: #000;
      border-radius: 0.75rem;
      overflow: hidden;
      aspect-ratio: 16/9;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background-color: #000;
    }

    .chat-container {
      background-color: #27272a;
      border-radius: 0.75rem;
      display: flex;
      flex-direction: column;
      height: 100%;
      border: 1px solid #3f3f46;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: #18181b;
      border-radius: 4px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #7c3aed;
      border-radius: 4px;
    }

    .chat-message {
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      background-color: #3f3f46;
      word-wrap: break-word;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .chat-username {
      font-weight: 700;
      color: #a78bfa;
      margin-right: 0.5rem;
    }

    .chat-input-container {
      padding: 1rem;
      border-top: 1px solid #3f3f46;
      display: flex;
      gap: 0.5rem;
    }

    .stream-card {
      background-color: #27272a;
      border-radius: 0.75rem;
      padding: 1.5rem;
      border: 2px solid #3f3f46;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .stream-card:hover {
      border-color: #7c3aed;
      transform: translateY(-4px);
      box-shadow: 0 10px 30px rgba(124, 58, 237, 0.2);
    }

    .live-badge {
      background-color: #dc2626;
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }

    .live-badge::before {
      content: '';
      width: 8px;
      height: 8px;
      background-color: white;
      border-radius: 50%;
      display: inline-block;
    }

    .viewer-badge {
      background-color: #3f3f46;
      color: #d4d4d8;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .error-message {
      background-color: #7f1d1d;
      border: 1px solid #dc2626;
      color: #fecaca;
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      animation: shake 0.5s;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    .success-message {
      background-color: #14532d;
      border: 1px solid #16a34a;
      color: #bbf7d0;
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      animation: slideIn 0.3s;
    }

    .loading-spinner {
      border: 4px solid #3f3f46;
      border-top: 4px solid #7c3aed;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .hidden {
      display: none !important;
    }

    .offline-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      z-index: 10;
    }

    @media (max-width: 768px) {
      .desktop-layout {
        flex-direction: column;
      }
      
      .chat-container {
        height: 400px;
      }

      .video-container {
        aspect-ratio: 16/9;
      }
    }

    @media (min-width: 769px) {
      .desktop-layout {
        display: grid;
        grid-template-columns: 1fr 400px;
        gap: 1rem;
        height: calc(100vh - 120px);
      }

      .chat-container {
        height: 100%;
      }

      .video-container {
        height: 100%;
        aspect-ratio: auto;
      }
    }

    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      background-color: #3f3f46;
      color: #f9f9f9;
      text-align: center;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      white-space: nowrap;
      font-size: 0.875rem;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 0.5rem;
    }

    .status-online {
      background-color: #16a34a;
      box-shadow: 0 0 10px #16a34a;
    }

    .status-offline {
      background-color: #71717a;
    }

    .grid-streams {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      padding: 1rem 0;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #27272a;
      border: 2px solid #7c3aed;
      padding: 1rem 1.5rem;
      border-radius: 0.75rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      animation: slideInRight 0.3s ease;
      max-width: 400px;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .fade-in {
      animation: fadeIn 0.5s ease;
    }

    .slide-up {
      animation: slideUp 0.5s ease;
    }

    @keyframes slideUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="auth-screen" class="min-h-screen flex items-center justify-center p-4">
      <div class="card max-w-md w-full fade-in">
        <div class="text-center mb-8">
          <h1 class="text-5xl font-bold gradient-text mb-2">NanoStream</h1>
          <p class="text-gray-400">Ultra-low latency live streaming</p>
        </div>

        <div id="login-form">
          <h2 class="text-2xl font-bold mb-6">Sign In</h2>
          <div id="login-error" class="hidden error-message"></div>
          <div id="login-success" class="hidden success-message"></div>
          <form onsubmit="handleLogin(event)">
            <div class="mb-4">
              <label class="block text-sm font-semibold mb-2 text-gray-300">Username</label>
              <input type="text" id="login-username" class="input-field" required minlength="3" maxlength="20" autocomplete="username">
            </div>
            <div class="mb-6">
              <label class="block text-sm font-semibold mb-2 text-gray-300">Password</label>
              <input type="password" id="login-password" class="input-field" required minlength="6" autocomplete="current-password">
            </div>
            <button type="submit" class="btn-primary w-full mb-4">Sign In</button>
          </form>
          <div class="text-center">
            <button onclick="switchToRegister()" class="text-violet-400 hover:text-violet-300 font-semibold">
              Don't have an account? Register
            </button>
          </div>
        </div>

        <div id="register-form" class="hidden">
          <h2 class="text-2xl font-bold mb-6">Create Account</h2>
          <div id="register-error" class="hidden error-message"></div>
          <div id="register-success" class="hidden success-message"></div>
          <form onsubmit="handleRegister(event)">
            <div class="mb-4">
              <label class="block text-sm font-semibold mb-2 text-gray-300">Username</label>
              <input type="text" id="register-username" class="input-field" required minlength="3" maxlength="20" autocomplete="username">
              <p class="text-xs text-gray-400 mt-1">3-20 characters</p>
            </div>
            <div class="mb-4">
              <label class="block text-sm font-semibold mb-2 text-gray-300">Password</label>
              <input type="password" id="register-password" class="input-field" required minlength="6" autocomplete="new-password">
              <p class="text-xs text-gray-400 mt-1">Minimum 6 characters</p>
            </div>
            <div class="mb-6">
              <label class="block text-sm font-semibold mb-2 text-gray-300">Confirm Password</label>
              <input type="password" id="register-password-confirm" class="input-field" required minlength="6" autocomplete="new-password">
            </div>
            <button type="submit" class="btn-primary w-full mb-4">Create Account</button>
          </form>
          <div class="text-center">
            <button onclick="switchToLogin()" class="text-violet-400 hover:text-violet-300 font-semibold">
              Already have an account? Sign In
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="main-screen" class="hidden">
      <nav class="gradient-bg p-4 shadow-lg">
        <div class="max-w-7xl mx-auto flex items-center justify-between">
          <div class="flex items-center gap-4">
            <h1 class="text-2xl font-bold text-white">NanoStream</h1>
            <span class="status-indicator status-online"></span>
          </div>
          <div class="flex items-center gap-4">
            <span class="text-white font-semibold" id="current-username"></span>
            <button onclick="handleLogout()" class="btn-secondary">Logout</button>
          </div>
        </div>
      </nav>

      <div id="stream-selection" class="max-w-7xl mx-auto p-4">
        <div class="mb-8 slide-up">
          <h2 class="text-3xl font-bold mb-4">Join or Create Stream</h2>
          <div class="card">
            <div class="flex flex-col md:flex-row gap-4">
              <div class="flex-1">
                <label class="block text-sm font-semibold mb-2 text-gray-300">Room ID</label>
                <input type="text" id="room-id-input" class="input-field" placeholder="Enter room name (e.g., gaming-stream-1)" required>
              </div>
              <div class="flex items-end gap-2">
                <button onclick="joinRoom()" class="btn-primary">Join Stream</button>
                <button onclick="createStream()" class="btn-success">Create & Go Live</button>
              </div>
            </div>
          </div>
        </div>

        <div class="slide-up">
          <div class="flex items-center justify-between mb-4">
            <h2 class="text-2xl font-bold">Live Now</h2>
            <button onclick="refreshStreams()" class="btn-secondary">
              <span id="refresh-icon">🔄</span> Refresh
            </button>
          </div>
          <div id="active-streams-container" class="grid-streams">
            <div class="text-center text-gray-400 py-12">
              <div class="loading-spinner mx-auto mb-4"></div>
              <p>Loading active streams...</p>
            </div>
          </div>
        </div>
      </div>

      <div id="stream-room" class="hidden max-w-7xl mx-auto p-4">
        <div class="mb-4 flex items-center justify-between">
          <div class="flex items-center gap-4">
            <button onclick="leaveRoom()" class="btn-secondary">← Back</button>
            <h2 class="text-xl font-bold" id="current-room-name"></h2>
            <div id="stream-status-badge"></div>
          </div>
          <div class="flex items-center gap-4">
            <div class="viewer-badge">
              <span>👁️</span>
              <span id="viewer-count">0</span>
              <span>viewers</span>
            </div>
          </div>
        </div>

        <div class="desktop-layout">
          <div class="video-section">
            <div class="video-container">
              <video id="local-video" autoplay muted playsinline class="hidden"></video>
              <video id="remote-video" autoplay playsinline class="hidden"></video>
              <div id="stream-offline-overlay" class="offline-overlay">
                <div class="loading-spinner mb-4"></div>
                <p class="text-xl font-semibold">Stream is offline</p>
                <p class="text-gray-400">Waiting for broadcaster...</p>
              </div>
            </div>

            <div id="streamer-controls" class="hidden mt-4 flex gap-4 flex-wrap">
              <button id="go-live-btn" onclick="toggleStream()" class="btn-success">
                <span id="stream-btn-text">📡 Go Live</span>
              </button>
              <button onclick="toggleAudio()" class="btn-secondary" id="audio-btn">
                <span id="audio-icon">🔊</span> Mute
              </button>
              <button onclick="toggleVideo()" class="btn-secondary" id="video-btn">
                <span id="video-icon">📹</span> Stop Video
              </button>
            </div>

            <div id="viewer-controls" class="hidden mt-4">
              <div class="card">
                <p class="text-gray-400">Enjoying the stream? Start chatting!</p>
              </div>
            </div>
          </div>

          <div class="chat-section">
            <div class="chat-container">
              <div class="p-4 border-b border-gray-600">
                <h3 class="text-lg font-bold">Live Chat</h3>
              </div>
              <div id="chat-messages" class="chat-messages"></div>
              <div class="chat-input-container">
                <input 
                  type="text" 
                  id="chat-input" 
                  class="input-field flex-1" 
                  placeholder="Send a message..."
                  maxlength="500"
                  onkeypress="handleChatKeypress(event)"
                >
                <button onclick="sendMessage()" class="btn-primary">Send</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let socket;
    let currentUser = null;
    let currentRoom = null;
    let userRole = null;
    let localStream = null;
    let peerConnections = {};
    let isStreaming = false;
    let audioEnabled = true;
    let videoEnabled = true;

    const ICE_SERVERS = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 10
    };

    function initSocket() {
      socket = io({
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        reconnectionAttempts: Infinity,
        transports: ['websocket', 'polling']
      });

      socket.on('connect', () => {
        console.log('Connected to server');
        if (currentUser && currentRoom) {
          rejoinRoom();
        }
      });

      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        showNotification('Connection lost. Reconnecting...', 'error');
      });

      socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
      });

      socket.on('register-response', handleRegisterResponse);
      socket.on('login-response', handleLoginResponse);
      socket.on('room-joined', handleRoomJoined);
      socket.on('stream-started', handleStreamStarted);
      socket.on('stream-status-changed', handleStreamStatusChanged);
      socket.on('new-viewer', handleNewViewer);
      socket.on('viewer-left', handleViewerLeft);
      socket.on('viewer-ready', handleViewerReady);
      socket.on('viewer-requesting-stream', handleViewerRequestingStream);
      socket.on('offer', handleOffer);
      socket.on('answer', handleAnswer);
      socket.on('ice-candidate', handleIceCandidate);
      socket.on('new-message', handleNewMessage);
      socket.on('chat-history', handleChatHistory);
      socket.on('viewer-count', handleViewerCount);
      socket.on('stream-ended', handleStreamEnded);
      socket.on('active-streams-list', handleActiveStreamsList);
      socket.on('stream-error', handleStreamError);
      socket.on('join-error', handleJoinError);
    }

    function switchToRegister() {
      document.getElementById('login-form').classList.add('hidden');
      document.getElementById('register-form').classList.remove('hidden');
      clearAuthMessages();
    }

    function switchToLogin() {
      document.getElementById('register-form').classList.add('hidden');
      document.getElementById('login-form').classList.remove('hidden');
      clearAuthMessages();
    }

    function clearAuthMessages() {
      ['login-error', 'login-success', 'register-error', 'register-success'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.classList.add('hidden');
          el.textContent = '';
        }
      });
    }

    function handleRegister(event) {
      event.preventDefault();
      clearAuthMessages();

      const username = document.getElementById('register-username').value.trim();
      const password = document.getElementById('register-password').value;
      const confirmPassword = document.getElementById('register-password-confirm').value;

      if (password !== confirmPassword) {
        showError('register-error', 'Passwords do not match');
        return;
      }

      if (username.length < 3 || username.length > 20) {
        showError('register-error', 'Username must be between 3 and 20 characters');
        return;
      }

      if (password.length < 6) {
        showError('register-error', 'Password must be at least 6 characters');
        return;
      }

      socket.emit('register', { username, password });
    }

    function handleRegisterResponse(data) {
      if (data.success) {
        showSuccess('register-success', 'Account created successfully! Please sign in.');
        setTimeout(() => {
          switchToLogin();
          document.getElementById('login-username').value = data.username;
        }, 1500);
      } else {
        showError('register-error', data.error || 'Registration failed');
      }
    }

    function handleLogin(event) {
      event.preventDefault();
      clearAuthMessages();

      const username = document.getElementById('login-username').value.trim();
      const password = document.getElementById('login-password').value;

      if (!username || !password) {
        showError('login-error', 'Please enter username and password');
        return;
      }

      socket.emit('login', { username, password });
    }

    function handleLoginResponse(data) {
      if (data.success) {
        currentUser = {
          userId: data.userId,
          username: data.username
        };

        localStorage.setItem('nanostream_user', JSON.stringify(currentUser));

        document.getElementById('auth-screen').classList.add('hidden');
        document.getElementById('main-screen').classList.remove('hidden');
        document.getElementById('current-username').textContent = data.username;

        showNotification(`Welcome back, ${data.username}!`, 'success');
        loadActiveStreams();
      } else {
        showError('login-error', data.error || 'Invalid credentials');
      }
    }

    function handleLogout() {
      if (currentRoom) {
        leaveRoom();
      }

      currentUser = null;
      localStorage.removeItem('nanostream_user');

      document.getElementById('main-screen').classList.add('hidden');
      document.getElementById('auth-screen').classList.remove('hidden');
      
      clearAuthMessages();
      document.getElementById('login-username').value = '';
      document.getElementById('login-password').value = '';
    }

    function joinRoom() {
      const roomId = document.getElementById('room-id-input').value.trim();
      
      if (!roomId) {
        showNotification('Please enter a room ID', 'error');
        return;
      }

      if (roomId.length < 3 || roomId.length > 50) {
        showNotification('Room ID must be between 3 and 50 characters', 'error');
        return;
      }

      currentRoom = roomId;
      socket.emit('join-room', { 
        roomId: currentRoom, 
        userId: currentUser.userId 
      });
    }

    function createStream() {
      const roomId = document.getElementById('room-id-input').value.trim();
      
      if (!roomId) {
        showNotification('Please enter a room ID', 'error');
        return;
      }

      if (roomId.length < 3 || roomId.length > 50) {
        showNotification('Room ID must be between 3 and 50 characters', 'error');
        return;
      }

      currentRoom = roomId;
      socket.emit('join-room', { 
        roomId: currentRoom, 
        userId: currentUser.userId 
      });
    }

    function rejoinRoom() {
      if (currentRoom) {
        socket.emit('join-room', { 
          roomId: currentRoom, 
          userId: currentUser.userId 
        });
      }
    }

    function handleRoomJoined(data) {
      userRole = data.role;
      currentRoom = data.roomId;

      document.getElementById('stream-selection').classList.add('hidden');
      document.getElementById('stream-room').classList.remove('hidden');
      document.getElementById('current-room-name').textContent = data.roomId;

      if (userRole === 'streamer') {
        setupStreamerUI();
      } else {
        setupViewerUI(data.streamActive);
      }

      updateStreamStatusBadge(data.streamActive);
    }

    function setupStreamerUI() {
      document.getElementById('streamer-controls').classList.remove('hidden');
      document.getElementById('viewer-controls').classList.add('hidden');
      document.getElementById('stream-offline-overlay').classList.add('hidden');
      document.getElementById('local-video').classList.remove('hidden');
      document.getElementById('remote-video').classList.add('hidden');
    }

    function setupViewerUI(streamActive) {
      document.getElementById('streamer-controls').classList.add('hidden');
      document.getElementById('viewer-controls').classList.remove('hidden');
      document.getElementById('local-video').classList.add('hidden');
      document.getElementById('remote-video').classList.remove('hidden');

      if (streamActive) {
        document.getElementById('stream-offline-overlay').classList.add('hidden');
        socket.emit('viewer-ready', { roomId: currentRoom });
        setTimeout(() => {
          socket.emit('request-stream', { roomId: currentRoom });
        }, 500);
      } else {
        document.getElementById('stream-offline-overlay').classList.remove('hidden');
      }
    }

    async function toggleStream() {
      if (!isStreaming) {
        await startStreaming();
      } else {
        stopStreaming();
      }
    }

    async function startStreaming() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 60 }
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        const localVideo = document.getElementById('local-video');
        localVideo.srcObject = localStream;
        localVideo.muted = true;

        socket.emit('start-stream', {
          roomId: currentRoom,
          userId: currentUser.userId
        });

        isStreaming = true;
        updateStreamButton();

      } catch (error) {
        console.error('Error starting stream:', error);
        showNotification('Failed to access camera/microphone. Please grant permissions.', 'error');
      }
    }

    function stopStreaming() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      Object.keys(peerConnections).forEach(viewerId => {
        if (peerConnections[viewerId]) {
          peerConnections[viewerId].close();
          delete peerConnections[viewerId];
        }
      });

      socket.emit('stop-stream', {
        roomId: currentRoom,
        userId: currentUser.userId
      });

      const localVideo = document.getElementById('local-video');
      localVideo.srcObject = null;

      isStreaming = false;
      updateStreamButton();
    }

    function updateStreamButton() {
      const btn = document.getElementById('go-live-btn');
      const btnText = document.getElementById('stream-btn-text');
      
      if (isStreaming) {
        btn.classList.remove('btn-success');
        btn.classList.add('btn-danger');
        btnText.textContent = '🔴 Stop Stream';
      } else {
        btn.classList.remove('btn-danger');
        btn.classList.add('btn-success');
        btnText.textContent = '📡 Go Live';
      }
    }

    function handleStreamStarted(data) {
      updateStreamStatusBadge(true);
      showNotification('Stream started successfully!', 'success');
    }

    function handleStreamStatusChanged(data) {
      updateStreamStatusBadge(data.active);

      if (userRole === 'viewer') {
        if (data.active) {
          document.getElementById('stream-offline-overlay').classList.add('hidden');
          socket.emit('viewer-ready', { roomId: currentRoom });
          setTimeout(() => {
            socket.emit('request-stream', { roomId: currentRoom });
          }, 500);
        } else {
          document.getElementById('stream-offline-overlay').classList.remove('hidden');
          const remoteVideo = document.getElementById('remote-video');
          remoteVideo.srcObject = null;
        }
      }
    }

    function updateStreamStatusBadge(active) {
      const badge = document.getElementById('stream-status-badge');
      if (active) {
        badge.innerHTML = '<span class="live-badge">Live</span>';
      } else {
        badge.innerHTML = '<span class="viewer-badge"><span class="status-indicator status-offline"></span>Offline</span>';
      }
    }

    async function handleNewViewer(data) {
      if (userRole !== 'streamer' || !isStreaming) return;

      const viewerId = data.viewerId;
      await createPeerConnection(viewerId);
    }

    async function createPeerConnection(viewerId) {
      if (peerConnections[viewerId]) {
        peerConnections[viewerId].close();
      }

      const pc = new RTCPeerConnection(ICE_SERVERS);
      peerConnections[viewerId] = pc;

      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('ice-candidate', {
            candidate: event.candidate,
            targetId: viewerId
          });
        }
      };

      pc.onconnectionstatechange = () => {
        console.log(`Connection state with ${viewerId}:`, pc.connectionState);
        if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
          setTimeout(() => {
            if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
              pc.close();
              delete peerConnections[viewerId];
            }
          }, 5000);
        }
      };

      try {
        const offer = await pc.createOffer({
          offerToReceiveAudio: false,
          offerToReceiveVideo: false
        });
        await pc.setLocalDescription(offer);

        socket.emit('offer', {
          offer: offer,
          viewerId: viewerId,
          roomId: currentRoom
        });
      } catch (error) {
        console.error('Error creating offer:', error);
      }
    }

    async function handleOffer(data) {
      if (userRole !== 'viewer') return;

      const streamerId = data.streamerId;
      
      if (peerConnections[streamerId]) {
        peerConnections[streamerId].close();
      }

      const pc = new RTCPeerConnection(ICE_SERVERS);
      peerConnections[streamerId] = pc;

      pc.ontrack = (event) => {
        const remoteVideo = document.getElementById('remote-video');
        if (remoteVideo.srcObject !== event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
          document.getElementById('stream-offline-overlay').classList.add('hidden');
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('ice-candidate', {
            candidate: event.candidate,
            targetId: streamerId
          });
        }
      };

      pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        if (pc.connectionState === 'connected') {
          showNotification('Connected to stream', 'success');
        } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
          document.getElementById('stream-offline-overlay').classList.remove('hidden');
          showNotification('Connection lost', 'error');
        }
      };

      try {
        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        socket.emit('answer', {
          answer: answer,
          streamerId: streamerId
        });
      } catch (error) {
        console.error('Error handling offer:', error);
      }
    }

    async function handleAnswer(data) {
      const viewerId = data.viewerId;
      const pc = peerConnections[viewerId];

      if (pc) {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        } catch (error) {
          console.error('Error handling answer:', error);
        }
      }
    }

    async function handleIceCandidate(data) {
      const senderId = data.senderId;
      const pc = peerConnections[senderId];

      if (pc && data.candidate) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch (error) {
          console.error('Error adding ICE candidate:', error);
        }
      }
    }

    function handleViewerLeft(data) {
      const viewerId = data.viewerId;
      if (peerConnections[viewerId]) {
        peerConnections[viewerId].close();
        delete peerConnections[viewerId];
      }
    }

    function handleViewerReady(data) {
      if (userRole === 'streamer' && isStreaming) {
        createPeerConnection(data.viewerId);
      }
    }

    function handleViewerRequestingStream(data) {
      if (userRole === 'streamer' && isStreaming) {
        createPeerConnection(data.viewerId);
      }
    }

    function toggleAudio() {
      if (localStream) {
        audioEnabled = !audioEnabled;
        localStream.getAudioTracks().forEach(track => {
          track.enabled = audioEnabled;
        });

        const audioIcon = document.getElementById('audio-icon');
        const audioBtn = document.getElementById('audio-btn');
        
        if (audioEnabled) {
          audioIcon.textContent = '🔊';
          audioBtn.innerHTML = '<span id="audio-icon">🔊</span> Mute';
        } else {
          audioIcon.textContent = '🔇';
          audioBtn.innerHTML = '<span id="audio-icon">🔇</span> Unmute';
        }
      }
    }

    function toggleVideo() {
      if (localStream) {
        videoEnabled = !videoEnabled;
        localStream.getVideoTracks().forEach(track => {
          track.enabled = videoEnabled;
        });

        const videoIcon = document.getElementById('video-icon');
        const videoBtn = document.getElementById('video-btn');
        
        if (videoEnabled) {
          videoIcon.textContent = '📹';
          videoBtn.innerHTML = '<span id="video-icon">📹</span> Stop Video';
        } else {
          videoIcon.textContent = '🚫';
          videoBtn.innerHTML = '<span id="video-icon">🚫</span> Start Video';
        }
      }
    }

    function sendMessage() {
      const input = document.getElementById('chat-input');
      const message = input.value.trim();

      if (!message) return;

      if (message.length > 500) {
        showNotification('Message too long (max 500 characters)', 'error');
        return;
      }

      socket.emit('send-message', {
        roomId: currentRoom,
        userId: currentUser.userId,
        message: message
      });

      input.value = '';
    }

    function handleChatKeypress(event) {
      if (event.key === 'Enter') {
        sendMessage();
      }
    }

    function handleNewMessage(data) {
      const messagesContainer = document.getElementById('chat-messages');
      const messageElement = document.createElement('div');
      messageElement.className = 'chat-message';
      
      const usernameSpan = document.createElement('span');
      usernameSpan.className = 'chat-username';
      usernameSpan.textContent = data.username + ':';
      
      const messageText = document.createTextNode(' ' + data.message);
      
      messageElement.appendChild(usernameSpan);
      messageElement.appendChild(messageText);
      
      messagesContainer.appendChild(messageElement);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function handleChatHistory(data) {
      const messagesContainer = document.getElementById('chat-messages');
      messagesContainer.innerHTML = '';

      if (data.messages && data.messages.length > 0) {
        data.messages.forEach(msg => {
          const messageElement = document.createElement('div');
          messageElement.className = 'chat-message';
          
          const usernameSpan = document.createElement('span');
          usernameSpan.className = 'chat-username';
          usernameSpan.textContent = msg.username + ':';
          
          const messageText = document.createTextNode(' ' + msg.message);
          
          messageElement.appendChild(usernameSpan);
          messageElement.appendChild(messageText);
          
          messagesContainer.appendChild(messageElement);
        });
        
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
    }

    function handleViewerCount(data) {
      document.getElementById('viewer-count').textContent = data.count;
    }

    function handleStreamEnded() {
      if (userRole === 'viewer') {
        const remoteVideo = document.getElementById('remote-video');
        remoteVideo.srcObject = null;
        document.getElementById('stream-offline-overlay').classList.remove('hidden');
        showNotification('Stream has ended', 'info');
      }
    }

    function leaveRoom() {
      if (isStreaming) {
        stopStreaming();
      }

      Object.keys(peerConnections).forEach(peerId => {
        if (peerConnections[peerId]) {
          peerConnections[peerId].close();
          delete peerConnections[peerId];
        }
      });

      if (currentRoom) {
        socket.emit('leave-room', { roomId: currentRoom });
      }

      currentRoom = null;
      userRole = null;

      document.getElementById('stream-room').classList.add('hidden');
      document.getElementById('stream-selection').classList.remove('hidden');
      document.getElementById('chat-messages').innerHTML = '';
      document.getElementById('room-id-input').value = '';

      const localVideo = document.getElementById('local-video');
      const remoteVideo = document.getElementById('remote-video');
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      loadActiveStreams();
    }

    function loadActiveStreams() {
      socket.emit('get-active-streams');
    }

    function refreshStreams() {
      const icon = document.getElementById('refresh-icon');
      icon.style.transform = 'rotate(360deg)';
      icon.style.transition = 'transform 0.5s';
      
      setTimeout(() => {
        icon.style.transform = 'rotate(0deg)';
      }, 500);

      loadActiveStreams();
    }

    function handleActiveStreamsList(data) {
      const container = document.getElementById('active-streams-container');
      container.innerHTML = '';

      if (data.streams && data.streams.length > 0) {
        data.streams.forEach(stream => {
          const streamCard = document.createElement('div');
          streamCard.className = 'stream-card';
          streamCard.onclick = () => {
            document.getElementById('room-id-input').value = stream.room_id;
            joinRoom();
          };

          const header = document.createElement('div');
          header.className = 'flex items-center justify-between mb-3';

          const liveBadge = document.createElement('span');
          liveBadge.className = 'live-badge';
          liveBadge.textContent = 'Live';

          header.appendChild(liveBadge);

          const roomName = document.createElement('h3');
          roomName.className = 'text-xl font-bold mb-2';
          roomName.textContent = stream.room_id;

          const streamerName = document.createElement('p');
          streamerName.className = 'text-gray-400 mb-3';
          streamerName.textContent = `Streamer: ${stream.username || 'Unknown'}`;

          const footer = document.createElement('div');
          footer.className = 'flex items-center justify-between';

          const viewerCount = document.createElement('span');
          viewerCount.className = 'text-gray-400 text-sm';
          viewerCount.textContent = `👁️ ${stream.viewer_count || 0} watching`;

          const joinBtn = document.createElement('button');
          joinBtn.className = 'btn-primary text-sm';
          joinBtn.textContent = 'Watch';

          footer.appendChild(viewerCount);
          footer.appendChild(joinBtn);

          streamCard.appendChild(header);
          streamCard.appendChild(roomName);
          streamCard.appendChild(streamerName);
          streamCard.appendChild(footer);

          container.appendChild(streamCard);
        });
      } else {
        container.innerHTML = `
          <div class="col-span-full text-center text-gray-400 py-12">
            <p class="text-xl mb-2">No live streams right now</p>
            <p>Be the first to go live!</p>
          </div>
        `;
      }
    }

    function handleStreamError(data) {
      showNotification(data.error || 'Stream error occurred', 'error');
    }

    function handleJoinError(data) {
      showNotification(data.error || 'Failed to join room', 'error');
      leaveRoom();
    }

    function showError(elementId, message) {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = message;
        element.classList.remove('hidden');
      }
    }

    function showSuccess(elementId, message) {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = message;
        element.classList.remove('hidden');
      }
    }

    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = 'notification';
      
      const colors = {
        success: '#16a34a',
        error: '#dc2626',
        info: '#7c3aed'
      };

      notification.style.borderColor = colors[type] || colors.info;
      notification.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="text-2xl">
            ${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}
          </div>
          <div>
            <p class="font-semibold">${message}</p>
          </div>
        </div>
      `;

      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = 'slideInRight 0.3s ease reverse';
        setTimeout(() => {
          notification.remove();
        }, 300);
      }, 4000);
    }

    window.addEventListener('DOMContentLoaded', () => {
      initSocket();

      const savedUser = localStorage.getItem('nanostream_user');
      if (savedUser) {
        try {
          const user = JSON.parse(savedUser);
          currentUser = user;
          document.getElementById('auth-screen').classList.add('hidden');
          document.getElementById('main-screen').classList.remove('hidden');
          document.getElementById('current-username').textContent = user.username;
          loadActiveStreams();
        } catch (error) {
          localStorage.removeItem('nanostream_user');
        }
      }

      setInterval(() => {
        if (currentRoom && socket.connected) {
          socket.emit('get-viewer-count', { roomId: currentRoom });
        }
      }, 3000);
    });

    window.addEventListener('beforeunload', () => {
      if (isStreaming) {
        stopStreaming();
      }
      if (currentRoom) {
        socket.emit('leave-room', { roomId: currentRoom });
      }
    });

    window.addEventListener('online', () => {
      showNotification('Connection restored', 'success');
      if (currentRoom) {
        rejoinRoom();
      }
    });

    window.addEventListener('offline', () => {
      showNotification('You are offline', 'error');
    });
  </script>
</body>
</html>
